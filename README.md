# Метод generate

Условия формирования армии:

* суммарная стоимость армии не превышает maxPoints;
* на каждый тип юнита действует ограничение не более 11;
* приоритет выбора типов:
    * максимальное отношение атака / стоимость;
    * при равенстве — здоровье / стоимость;
* все юниты размещаются в зоне противника слева на поле размером 3 × 21;
* координаты юнитов всегда уникальны (без наложений);
* для каждого созданного юнита копируется Program из шаблона типа;
* в объект Army записывается фактически потраченное количество очков.

## Алгоритм работы:

1. Создаётся копия входного списка типов юнитов и сортируется по эффективности:
    * baseAttack / cost по убыванию,
    * при равенстве health / cost по убыванию.
2. Генерируется список всех доступных клеток в зоне спавна 3 × 21, перемешивается и используется как источник уникальных координат.
3. Для каждого типа юнита вычисляется максимально возможное количество:
   min(11, remainingPoints / cost),
   после чего создаются юниты этого типа до исчерпания лимита, очков или свободных клеток.
4. Собранный список юнитов сохраняется в Army, а points устанавливается как сумма потраченных очков.

## Алгоритмическая сложность:

* сортировка типов юнитов по эффективности: O(n log n),
* создание юнитов (не более m) и распределение по клеткам: O(m),
* генерация клеток спавна: 3 × 21 = 63 — константа, O(1).

Итоговая сложность:

```
O(n log n + m)
```

---

# Метод simulate

## Алгоритм работы:

* бой проходит раундами — каждый раунд представляет собой один цикл ходов юнитов;
* в начале раунда формируются две очереди ходов, включающие только живых юнитов;
* порядок ходов внутри каждой армии определяется по убыванию атаки, при равенстве — по имени;
* ходы выполняются в режиме чередования армий: игрок → компьютер → игрок → компьютер, пока хотя бы в одной очереди остаются юниты;
* погибшие юниты не совершают ход: если юнит умер до своего хода, при извлечении из очереди он будет пропущен;
* после каждого хода производится логирование через printBattleLog.printBattleLog;
* бой корректно завершается:
    * если у одной из армий не осталось живых юнитов (hasAlive == false);
    * либо если за целый раунд не произошло ни одной успешной атаки (все действия возвращали null — цели недоступны).

## Алгоритмическая сложность

* построение списков живых юнитов и сортировка очередей в начале раунда:
  O(n log n), где n — общее число юнитов в обеих армиях;
* выполнение ходов в рамках раунда:
  O(n) (каждый юнит извлекается из очереди не более одного раза).

В худшем случае (при большом числе раундов) суммарная сложность оценивается как:
O(n² log n), где n — общее количество юнитов в обеих армиях, при предположении, что unit.getProgram().attack() работает за O(1).

---

# Метод getSuitableUnits

## Концепт алгоритма:

Метод формирует список юнитов, которые доступны для атаки.

* метод работает для обеих сторон:
    * при атаке компьютера выбираются юниты игрока, не прикрытые справа;
    * при атаке игрока выбираются юниты компьютера, не прикрытые слева;
* добавляются только живые юниты, null и мёртвые не учитываются;
* если в слое/во всех слоях нет живых юнитов — возвращается пустой список;
* используется HashSet<Integer> для хранения занятых “фронтовых” координат y:
    * если y уже встречался на более фронтовом слое, значит юнит с таким y прикрыт и в результат не добавляется;
* нет сортировок и лишних пересчётов, что позволяет эффективно вызывать метод в цикле боя.

## Алгоритмическая сложность:

Алгоритм выполняет один проход по всем слоям и юнитам, выполняя операции HashSet за амортизированное O(1).

* Временная сложность: O(n · m), при m = 3 ⇒ O(n).
* Дополнительная память: O(n) на множество y и список результата.

Где:
* n — количество юнитов (в среднем/максимально) в одном слое;
* m — количество слоёв (всегда равно 3).

---

# Метод getTargetPath

## Концепт алгоритма:

Метод ищет кратчайший путь от атакующего юнита до целевого юнита на игровом поле фиксированного размера W × H (27 × 21) и возвращает путь в виде списка Edge включая стартовую и конечную клетки.

* на поле могут находиться другие живые юниты, которые блокируют клетки — такие клетки отмечаются в массиве blocked;
* поиск пути выполняется с помощью алгоритма A***:
    * `gScore[cell]` хранит стоимость пути от старта до клетки (число шагов);
    * приоритет клетки задаётся значением `f = gScore + heuristic`;
    * используется допустимая эвристика `heuristic` — **расстояние Чебышёва, подходящее для движения в 8 направлениях при одинаковой цене шага;
* для выбора следующей клетки используется очередь с приоритетом (PriorityQueue), где извлекается вершина с минимальным f;
* соседние клетки проверяются по 8 направлениям (включая диагонали);
* посещённые клетки помечаются в closed, что предотвращает зацикливание;
* если путь найден, метод восстанавливает маршрут по массиву parent (предыдущая клетка для каждой позиции) и возвращает его как List<Edge>;
* если путь недоступен — возвращается пустой список.

## Алгоритмическая сложность:

Алгоритм использует PriorityQueue:

* операция извлечения и вставки имеет сложность O(log K), где K — размер очереди;
* в худшем случае K ≤ V, поэтому каждая операция выполняется за O(log(W · H)).
 
Где:
* размер поля: всего V = W · H клеток (вершин графа);
* в худшем случае алгоритм может обработать большинство (или все) из этих клеток.

Для каждой обрабатываемой клетки выполняется просмотр до 8 соседей (константа), и возможные операции вставки в очередь.

Итоговая сложность по времени:

```
O(W · H · log(W · H))
```

## Сложность по памяти

Используемые структуры данных:

* blocked — O(W · H)
* gScore — O(W · H)
* parent — O(W · H)
* closed — O(W · H)
* open (PriorityQueue) — в худшем случае O(W · H)
* список пути — до O(W · H)

Итоговая сложность по памяти:
```
O(W · H)
```
